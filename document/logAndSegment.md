## 로그와 로그 세그먼트

* 카프카의 토픽으로 들어오는 메세지(Record)는 로그 세그먼트(Log Segment, 세그먼트라고도함) 파일에 저장된다.
* 로그 세그먼트에는 메시지의 내용, 키, 벨류, 오프셋, 메세지 크기 같은 정보가 저장된다.
* 로그 세그먼트 파일은 브로커의 로컬 디스크에 보관된다.

* 로그 세그먼트 크기가 너무 커져버리면 파일을 관리하기 어렵기 때문에, 로그 세그먼트의 최대 크기는 1GB 가 기본값으로 설정되어있다.
* 로그 세그먼트 파일은 로그 세그먼트 인덱스 파일을 가지고 있다. 이 파일은 로그 세그먼트 파일에 있는 메세지의 오프셋과 위치를 가지고 있다.
* 로그 세그먼트 크기가 1GB 보다 커지면 기본적으로 롤링 전략을 사용한다.
* 다시 말해, 1GB 가 넘어가면 해당 파일을 클로즈하고, 새로운 로그 세그먼트 파일을 만든다.
* 카프카 관리자는 1GB 크기의 로그 세그먼트 파일이 무한정 늘어나는 경우를 고려해 관리 계획을 수립해야한다.

* 로그 세그먼트 삭제 정책은 다음과 같다.
    * delete
    * compact
    * delete, compact

### 로그 세그먼트 삭제

* 로그 세그먼트 삭제 정책은 디폴트이기 때문에 따로 명시하지 않아도 된다.
* 명시하게되면 다음과 같은 옵션을 사용한다. -> log.cleanup.policy : delete
* retention.ms 옵션을 사용하면 로그 세그먼트 보관 시간이 해당 숫자보다 크면 삭제한다는 명령이다. -> 기본값 7일
* 로그 세그먼트의 삭제 작업은 일정 주기를 가지고 체크하는데, 카프카의 기본값은 5분 주기로 되어있다. 따라서 5분 주기마다 삭제된다.
* retention.bytes 값을 사용하여 지정된 크기를 기준으로도 삭제할 수 있다.

### 로그 세그먼트 컴팩션(압축)

* 삭제하지 않고, 압축하여 보관할 수 있다.
* 압축할지라도 카프카의 로컬 디스크에 무한정 보관하면, 로그의 용량은 감당할 수 없이 커져서 디스크가 가득차게 될 수 있다.
* 따라서, 카프카는 단순하게 압축하는 것이 아닌, 메세지의 키 값을 기준으로 마지막 데이터만 보관한다.
* 컨슈머 그룹은 항상 마지막으로 커밋된 오프셋 정보가 중요하므로, 과거에 커밋된 정보들은 삭제해도 괜찮다.

* 로그 컴팩션의 장점은 빠른 장애 복구를 할 수 있다.
* 장애 복구 시 전체 로그를 복구하지 않고, 메세지의 키를 기준으로 최신의 상태만 복구를 할 수 있다.
* 모든 토칙에 로그 컴팩션을 적용하는 것은 좋지 않다. 키값을 기준으로 최종값만 필요한 워크로드에 적용하는 것이 바람직하다.
