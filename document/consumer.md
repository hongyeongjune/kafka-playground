## Consumer

### 컨슈머 오프셋 관리
* 컨슈머 그룹은 오프셋 정보를 카프카에서 가장 안전한 저장소인 토픽에 저장한다. 이 토픽의 이름은 __consumer_offsets 이다.
* __consumer_offsets 토픽에는 각 컨슈머 그룹별로 오프셋 위치 정보가 기록된다.
* 컨슈머들은 지정된 토픽의 메세지를 읽은 뒤, 읽어온 위치의 오프셋 정보를 __consumer_offsets 토픽에 기록한다.
* 이때 컨슈머 그룹은 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합해 기록한다.
* __consumer_offsets 토픽에 기록된 정보를 이용해 컨슈머 그룹은 자신의 그룹이 속해 있는 컨슈머의 변경이 발생하면 해당 컨슈머가 어디까지 읽었는지를 추적할 수 있다.
* 여기저 저장되는 오프셋 값은 마지막까지 읽은 위치는 아니고 컨슈머가 다음으로 읽어야 할 위치다.

### 그룹 코디네이터
* 컨슈머들은 하나의 컨슈머 그룹의 구성원으로 속한다.
* 컨슈머 그룹 내의 각 컨슈머들은 서로 자신의 정보를 공유하며 하나의 공동체로 동작한다.
* 컨슈머 그룹 내의 컨슈머들은 언제든지 자신이 속한 컨슈머 그룹을 떠날 수 있으며 새로운 컨슈머가 합류할 수도 있다.
* 컨슈머 그룹에서 각 컨슈머들에게 작업을 균등하게 분배하는 동작을 컨슈머 리밸런싱이라고 부른다.
* 그룹 코디네이터는 컨슈머 그룹의 안정성과 리밸런싱 과정을 주도한다.
* 그룹 코디네티어는 각 컨슈머 그룹별로 존재하며, 그룹 코디네이터는 카프카 클러스터 내 브로커 중 하나에 위치한다.
* 컨슈머 그룹이 브로커에 최초 연결 요청을 보내면 브로커 중 하나에 그룹 코디네이터가 생성되고 이 그룹 코디네이터는 컨슈머 그룹의 변경과 구독하는 토픽 파티션 변견 등에 대한 감지를 시작한다.
* 그리고 토픽의 파티션과 그룹의 멤버 변경이 일어나면 변경된 내용들을 컨슈머들에게 알려준다.

### 컨슈머 그룹 등록 과정
1. 컨슈머는 bootstrap.brokers 리스트에 있는 브로커에게 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보낸다.
2. 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답을 보낸다.
3. 그룹 코디네이터는 group.initial.rebalance.delay.ms 시간 동안 컨슈머의 요청을 기다린다.
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보낸다. 이때 가장 먼저 요청한 컨슈머가 그룹의 리더가 된다.
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보낸다.
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달한다.
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알린다.
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메세지들을 가져온다.

### 스태틱 멤버십
* 카프카 2.3 버전 이전에서는 하트비트 주기, 세션 타임아웃 등 설정으로 컨슈머가 재시작할 때마다 전체 리밸런싱이 일어났다.
* 왜냐하면 컨슈머 그룹에서는 각 컨슈머를 식별하기 위해 엔티티 ID 를 부여하게 되는데, 그룹 내에서 임시로 사용되는 값이기 때문에 컨슈머가 재시작되면, 그룹 내 동일한 컨슈머임에도 새로운 컨슈머로 인식해 새로운 엔티티 ID 가 부여되고 리밸런싱이 일어나게된다.
* 카프카 2.3 버전 이후에서는 스태틱 멤버실을 도입하여 컨슈머가 재시작 등으로 그룹을 나갔다 합류하더라도 리밸런싱이 일어나지 않는다.
* 즉, 컨슈머마다 인식할 수 있는 고유의 ID 를 부여하여 다시 합류하더라도 그룹 코디네이터가 기존 구성원임을 인식할 수 있게 한다.
* 또한, 스태틱 멤버십이 적용된 컨슈머는 그룹에서 떠날 때 그룹 코디네이터에게 알리지 않으므로 불필요한 리밸런싱도 발생하지 않게된다.
* ```group.instance.id``` 만 설정하면 스태틱 멤버십이 적용된다.
* 스태틱 멤버십이 적용되면 ```session.timeout.ms```를 기본값보다는 큰 값으로 조정해야한다. 컨슈머를 재시작한 후 ```session.timeout.ms``` 값에 지정된 시간동안 그룹 코디네이터가 하트비트를 받지 못하면 리밸런싱이 일어나게 될 수 있기 때문이다.

### 레인지 파티션 할당 전략
* 파티션 할당 전략 중 기본값
* 먼저 구독하는 토픽에 대한 파티션을 순서대로 나열 후 컨슈머를 순서대로 정렬하고 각 컨슈머가 몇 개의 파티션을 할당해야 하는지 전체 파티션 수를 컨슈머 수로 나눈다.
* 컨슈머 수와 파티션 수가 일치하면 균등하게 나눠지고 아니라면 앞쪽의 컨슈머들은 추가 할당을 받게 된다.
* 예를 들어 토픽1에 파티션이 3개 있고 컨슈머 그룹 내 컨슈머가 2개라면 3/2 = 1 이므로 컨슈머당 최소 한개를 가져야한다. 균등하게 나눠지지 않았으므로 첫 번쨰 컨슈머가 2개를 할당받게 된다.
* 동일한 메세지 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용하다. 즉, 동일한 컨슈머가 동일한 키를 계속 소비하므로 일관성을 보장할 수 있다.

### 라운드 로빈 파티션 할당 전략
* 먼저 컨슘해야 하는 모든 파티션과 그룹 내 모든 컨슈머를 나열한 후 라운드 로빈으로 하나씩 파티션과 컨슈머를 할당하는 방식
* 따라서, 레인지 파티션보다는 균등하게 할당된다.

### 스티키 파티션 할당 전략
* 레인지 파티션과 라운드 로빈 파티션 둘 다 리밸런싱 동작으로 파티션이 재할당되면 동일한 컨슈머에 파티션이 매핑되리라고는 보장할 수 없다.
* 스티키 파티션 전략은 재할당 작업이 발생하더라도 기존에 매핑됐던 파티션과 컨슈머를 최대한 유지하려고 하는 전략이다.
* 스티키 파티션 전략은 가능한 한 균형 잡힌 파티션 할당, 재할당이 발생할 때 되도록 기존에 할당된 파티션 정보를 보장하는 것을 원칙으로 한다. 여기서 전자가 우선순위가 더 높다. 즉, 무조건 기존 파티션과 컨슈머를 유지하지는 않는다.
* 라운드 로빈 방식은 파티션이 재할당되면 모든 파티션과, 컨슈머를 순서대로 배치후 처음부터 하나씩 할당한다.
* 스티키 파티션 전략은 특정 컨슈머가 제외되었을 떄 기존에 할당되어있던 파티션은 그대로 두고 제외된 컨슈머에 할당되었었던 파티션들만 재할당을 하게된다.
* 스티키 파티션 전략은 다음과 같은 규칙이 있다.
  * 컨슈머들의 최대 할당된 파티션의 수의 차이는 1
  * 기존에 존재하는 파티션 할당은 최대한 유지함
  * 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거함
  * 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당

### 협력적 스티키 파티션 할당 전략
* 결과만 보면 스티키 파티션 할당 전략과 동일하다.
* 협력적 스티키 파티션 할당 전략은 컨슈머 내부 리밸런싱 동작이 한층 고도화되었다.
* 컨슈머 리밸런싱이 일어나면 내부적으로 EAGER 라는 리밸런스 프로토콜을 사용한다. EAGER 프로토콜은 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소한다.
* 취소하는 이유는 다음과 같다.
  * 컨슈머들의 파티션 소유권 변경 때문 -> A 컨슈머가 갖고 있는 0번 파티션의 소유권을 B 컨슈머에게 할당해야할 때 하나의 컨슈머 그룹 내에서는 둘 이상의 컨슈머가 동일한 파티션을 소유할 수 없으므로
  * 그룹 내에서 여러 파티션들에 대해 소유권 변경 작업이 동시에 이뤄져야하는데 이 로직을 단순하게 구현하기 위해서
* 리밸런싱 중 모든 파티션을 취소하면 컨슈머의 다운타임이 시작된다. 이 때 다운타임 동안 LAG 이 급격하게 증가할 수 있다.
* 카프카 2.3 버전 이후부터는 협렵적 스티키는 내부 리밸런싱 프로토콜을 COOPERATIVE 을 사용했고, 이 프로토콜은 리밸런싱이 동작하기 전의 컨슈머의 상태를 유지할 수 있다. 즉, 동작 중인 컨슈머들에게 영향을 주지 않는 상태에서 몇 차례에 걸쳐 리밸런싱이 이뤄진다.
* 예를 들어 파티션이 3개 있고 그룹 내 컨슈머가 2개 있는 상황에서 컨슈머 하나가 새롭게 합류한다고 가정하면 다음과 같다.
  * 컨슈머 그룹에 consumer3 이 합류하면서 리밸런싱이 트리거된다.
  * 그룹 내 컨슈머들은 그룹 합류 요청과 자신들이 컨슘하는 토픽의 파티션 정보를 그룹 코디네이터로 전송한다.
  * 그룹 코디네이터는 해당 정보를 조합해 컨슈머 그룹의 리더에게 전송한다.
  * 그룹의 리더는 현재 컨슈머들이 소유한 파티션 정보를 활용해 제외해야 할 파티션 정보를 담은 새로운 파티션 할당 정보를 컨슈머 그룹 멤버들에게 전달한다. (리밸런싱 첫 번째 진행)
  * 제외된 파티션 할당을 위해 컨슈머들은 다시 합류 요청을 합니다.
  * 컨슈머 그룹의 리더는 제외된 파티션을 적절한 컨슈머에게 할당한다. (리밸런싱 두 번째 진행)
* 위 예시처럼 리밸런싱을 2번에 결쳐서 진행했고, 기존 컨슈머들은 다운타임 없이 계속 동작할 수 있다.
* EAGER 보다 COOPERATIVE 성능 비교 결과 : https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/

